#不适合用递归，会存在大量重复的递归计算，例如 f(n) 和 f(n-1) 两者向下递归需要各自计算 f(n-2)的值
#若用记忆化递归，即在递归的基础上，新建一个长度n的数组，用于在递归时存储f(0)至f(n)的数字值，遇到重复数字直接取用，虽避免了重复的递归计算，但需要额外的O(n)空间
#动态规划，以斐波那契数列性质 f(n+1)=f(n)+f(n-1)为转移方程
class Solution:
    def fib(self, n: int) -> int:
        a, b = 0, 1
        for _ in range(n):
            a, b = b, a + b
        return a % 1000000007