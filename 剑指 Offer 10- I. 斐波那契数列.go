//不适合用递归，会存在大量重复的递归计算，例如 f(n) 和 f(n-1) 两者向下递归需要各自计算 f(n-2)的值
//若用记忆化递归，即在递归的基础上，新建一个长度n的数组，用于在递归时存储f(0)至f(n)的数字值，遇到重复数字直接取用，虽避免了重复的递归计算，但需要额外的O(n)空间
//动态规划，以斐波那契数列性质 f(n+1)=f(n)+f(n-1)为转移方程
func fib(n int) int {
	const mod int = 1e9 + 7
	if n < 2 {
		return n
	}
	p, q, r := 0, 0, 1
	for i := 2; i <= n; i++ {
		p = q
		q = r
		r = (p + q) % mod
	}
	return r
}

